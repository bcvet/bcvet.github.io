## 源文件基础
### 文件名
源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 `.java`。

### 文件编码：UTF-8
源文件编码格式为 `UTF-8`。

### 特殊字符
使用制表符 `tab` 缩进，一个 `tab` 设为4个 `空格`。

---- 

## 源文件结构
一个源文件包含(按顺序地)：
1. 许可证或版权信息(如有需要)
	2. package语句
	3. import语句
	4. 一个顶级类(只有一个)
以上每个部分之间用一个空行隔开。

### 许可证或版权信息
如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。
	    /**
	     * Copyright (c) 2015-2016 百年视野 http://www.bcvet.com
	     * @author LiuDan & JinTongyao
	     * @version alpha
	     * 站点控制类
	     */

### package语句
package语句不换行，每个package语句独立成行

### import语句
- import不要使用通配符，即，不要出现类似这样的import语句：`import java.util.*;`
- import语句不换行，每个import语句独立成行
- import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：
	1. 所有的静态导入独立成组
	2. `com.bcvet` imports
	3. 第三方的包。每个顶级包为一组，字典序。例如：`android`, `com, junit`, `org`, `sun`
	4. `java` imports
	5. `javax` imports

### 类声明
每个顶级类都在一个与它同名的源文件中。
- 类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。
- **重载：永不分离**。当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。

## 格式
### 大括号
#### 使用大括号(即使是可选的)
大括号与`if`, `else`, `for`, `do`, `while`语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。
#### 非空块
1. 左大括号前不换行
2. 左大括号后换行
3. 右大括号前换行
4. 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。
	```Java
		return new MyClass() {
		  @Override public void method() {
		    if (condition()) {
		      try {
		        something();
		      } catch (ProblemException e) {
		        recover();
		      }
		    }
		  }
		};
	```

### 空块：可以用简洁版本
一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。
例外：如果它是一个多块语句的一部分(`if/else` 或 `try/catch/finally`) ，即使大括号内没内容，右大括号也要换行。
	    void doNothing() {}

### 一行一个语句
每个语句后要换行。

### 列限制：120
每行不应该超过120字符，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。
例外：
1. 不可能满足列限制的行(例如，Javadoc中的一个长URL)
	2. package和import语句
	3. 注释中那些可能被剪切并粘贴到shell中的命令行

### 自动换行
自动换行的基本准则是：**更倾向于在更高的语法级别处断开**。
1. 如果在 `非赋值运算符` 处断开，那么在该符号前断开(比如+，它将位于下一行)
	2. 如果在 `赋值运算符` 处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)
	3. 方法名或构造函数名与左括号留在同一行
	4. `逗号(,)` 与其前面的内容留在同一行
	5. 自动换行时缩进一个 `tab`

### 空白
#### 垂直空白(空行)
以下情况需要使用一个空行：
1. 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
	2. 在函数体内，语句的逻辑分组间使用空行。
	3. 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
#### 水平空白
除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：
1. 分隔任何保留字与紧随其后的左括号(`(`)(如`if`，`for`，`catch`等)
	2. 分隔任何保留字与其前面的右大括号(`}`)(如 `else`, `catch`)
	3. 在任何左大括号前(`{`)
	4. 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
	4. 类型界限中的&(`<T extends Foo & Bar>`)。
	5. catch块中的管道符号(`catch (FooException | BarException e`)
	5. 在 `,` `:` `;`后
	6. 如果在一条语句后做注释，则双斜杠(`//`)右边要空格。
	7. 数组初始化中，大括号内的空格是可选的，即 `new int[] {5, 6}` 和`new int[] { 5, 6 }` 都是可以的。
#### 水平对齐：不做要求
水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。
这是允许的(而且在不少地方可以看到这样的代码)，但编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。
	    private int x; // this is fine
	    private Color color; // this too
	
	    private int   x;      // permitted, but future edits
	    private Color color;  // may leave it unaligned

> 对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。

### 用小括号来限定组：推荐
除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。

### 具体结构
#### 枚举
枚举常量间用逗号隔开，换行可选。
没有方法和文档的枚举类可写成数组初始化的格式：
	private enum Suit {CLUBS, HEARTS, SPADES, DIAMONDS}
由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。
#### 变量声明
- 每次只声明一个变量。不要使用组合声明，比如 `int a, b;`
- 需要时才声明，并尽快进行初始化。不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化
#### 数组
- 数组初始化：可写成块状结构，比如，下面的写法都是OK的：

		    new int[] {1, 2, 3, 4, 5}       
		
		    new int[] {
		        0, 1, 2, 3 
		    }
		
		    new int[] {
		      0,
		      1,
		      2,
		      3
		    }
- 中括号是类型的一部分：`String[] args`， 而非 `String args[]`
#### switch语句
- 与其它块状结构一致，switch块中的内容缩进为一个 `tab`
- 每个switch标签后新起一行，再缩进一个 `tab`，写下一条或多条语句
- 每个switch语句都包含一个 `default` 语句组，即使它什么代码也不包含
#### 注释
- 块注释与其周围的代码在同一缩进级别。它们可以是 `/* ... */` 风格，也可以是 `// ...` 风格。对于多行的 `/* ... */` 注释，后续行必须从 `*` 开始， 并且与前一行的 `*` 对齐。以下示例注释都是OK的。
> 在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 `/* ... */`
- 方法与类需要完善注释。
- 方法注释中不再需要添加作者。
- 如果逻辑与原先有变化，则需要编写详细的注释。

---- 

## 命名约定
标识符只能使用ASCII字母和数字。
### 包名
包名全部小写，连续的单词只是简单地连接起来，不使用下划线。

### 类名
- 类名都以 `UpperCamelCase` 风格编写
- 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型
- 测试类的命名以它要测试的类的名称开始，以**Test**结束。例如，`HashTest` 或`HashIntegrationTest`

### 方法名
- 方法名都以 `lowerCamelCase` 风格编写。
- 方法名通常是动词或动词短语

### 常量名
常量名命名模式为 `CONSTANT_CASE`，全部字母大写，用下划线分隔单词。

### 参数名
参数名以 `lowerCamelCase` 风格编写。
参数应该避免用单个字符命名。

### 局部变量名
局部变量名以 `lowerCamelCase` 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。
虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。
即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。

---- 


## 编程实践
### @Override：能用则用
只要是合法的，就把 `@Override` 注解给用上。

### 捕获的异常：不能忽视
除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志)
如果它确实是不需要在catch块中做任何响应，需要做注释加以说明：
	        try {
		      int i = Integer.parseInt(response);
		      return handleNumericResponse(i);
		    } catch (NumberFormatException ok) {
			      // it's not numeric; that's fine, just continue
		    }
		    return handleTextResponse(response);
œ
### 静态成员：使用类进行调用
使用类名调用静态的类成员，而不是具体某个对象或表达式。
	    Foo aFoo = ...;
	    Foo.aStaticMethod(); // good
	    aFoo.aStaticMethod(); // bad


---- 
## 业务
- 输出提示信息使用 `log.info()`，输出错误信息使用 `log.error()`
- 方法实现可以不用写方法注释，使用 `@see` 注解和内容即可

---- 
